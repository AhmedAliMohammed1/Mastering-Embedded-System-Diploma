/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include "main.h"

/**================================================================
 * @Fn- Error_Handller
 * @brief - this fun shall to go in infinte loop if there is any thing wrong
 * @param [in] - void
 * @param [out] - Void
 * @retval -
 * Note-
 */
void Error_Handller(){
	while(1);
}


void Sys_Clk_init(){
	// system speed 28Mhz
	RCC->CFGR |=(0b0101 <<18); //1111: PLL input clock x 16
	//	RCC->CFGR |=(0b100<<8); //100: HCLK divided by 2
	//	RCC->CFGR |=(1 <<16); //PLL entry clock source
	//	RCC->CR|=(1<<16); //HSE clock enable

	RCC->CR|=(1<<24); //PLL ON
	RCC->CFGR |=(0b10 <<0); //10: PLL selected as system clock

}







/************DMS TASK*************/
/************DMS TASK*************/
/************DMS TASK*************/
/************DMS TASK*************/
/************DMS TASK*************/


void DMS_Handller_TASK(){
	while(1){
		if(xSemaphoreTake(DMS_Semaphore,5) ==pdTRUE){
			// here the action would take
			MCAL_USART_SendData(TSR_UART_INSTANT, DMS_TAKE_ACTION);
		}else{
			MCAL_USART_SendData(TSR_UART_INSTANT, DMS_Release_ACTION);
		}

	}
}
void DMS_read_TASK(){
	while(1){
		if(DMS_read() ==0){
			xSemaphoreGive(DMS_Semaphore);
		}

	}
}


/***********************************/
/***********************************/
/***********************************/
/***********************************/
/***********************************/
/***********************************/














/************ACC TASK*************/
/************ACC TASK*************/
/************ACC TASK*************/
/************ACC TASK*************/
/************ACC TASK*************/








uint16_t ACC_THROTTEL_DATA=0x00;
void ACC_ADC_CallBack(){
	ADC_read(ADC1,ACC_THROTTEL_CHx,&ACC_THROTTEL_DATA);

}

void ACC_throtel_init(){
	ADC_Analog_WDG AWDG={0,0,0,0};
	ADC_CONFIG config={ACC_THROTTEL_CHx,ADC_Continuous_conversion,ADC_1_5_cycles,ADC_Polling,&AWDG,ACC_ADC_CallBack};
	ADC_init(ADC1,&config);
//	ADC_interrupt_Enable(ADC1);
	PIN_config PINx={ACC_BOTTON_PIN,INPUT_PD,0};
	MCAL_GPIO_init(ACC_BOTTON_PORT, &PINx);

}
void ACC_DAC_init(){
	PIN_config PINx={ACC_DAC_0,OUTPUT_PP,SPEED_10};
	MCAL_GPIO_init(GPIOA, &PINx);
	PINx=(PIN_config){ACC_DAC_1,OUTPUT_PP,SPEED_10};
	MCAL_GPIO_init(GPIOB, &PINx);
	PINx=(PIN_config){ACC_DAC_2,OUTPUT_PP,SPEED_10};
	MCAL_GPIO_init(GPIOB, &PINx);
	PINx=(PIN_config){ACC_DAC_3,OUTPUT_PP,SPEED_10};
	MCAL_GPIO_init(GPIOB, &PINx);
	PINx=(PIN_config){ACC_DAC_4,OUTPUT_PP,SPEED_10};
	MCAL_GPIO_init(GPIOB, &PINx);
	PINx=(PIN_config){ACC_DAC_5,OUTPUT_PP,SPEED_10};
	MCAL_GPIO_init(GPIOB, &PINx);
	PINx=(PIN_config){ACC_DAC_6,OUTPUT_PP,SPEED_10};
	MCAL_GPIO_init(GPIOB, &PINx);
	PINx=(PIN_config){ACC_DAC_7,OUTPUT_PP,SPEED_10};
	MCAL_GPIO_init(GPIOB, &PINx);

}


/**================================================================
 * @Fn- TSR_START
 * @brief - this fun shall to start the frame of TSR
 * @param [in] - void
 * @param [out] - Void
 * @retval -
 * Note-
 */


uint16_t ACC_FROM_DAC_TO_ADC(uint8_t PWM_VAL){
	uint16_t ADC=(uint16_t)(((PWM_VAL*ACC_TROTTEL_Max_ADC_VAL_shifted)/(100))+ACC_TROTTEL_MIN_ADC_VAL);

	return ADC;
}
uint16_t ACC_FROM_ADC_TO_DAC_DATA(uint16_t ADC_VAL){
	uint16_t PWM=(uint16_t)(((ADC_VAL-ACC_TROTTEL_MIN_ADC_VAL)*100)/(ACC_TROTTEL_Max_ADC_VAL_shifted));
	return PWM;
}
void ACC_FROM_ADC_TO_DAC(uint16_t ADC_VAL){
	uint16_t PWM_V=((ADC_VAL-1000)/6);

	//	uint16_t PWM_V=(uint16_t)(((ADC_VAL-ACC_TROTTEL_MIN_ADC_VAL)*100)/(ACC_TROTTEL_Max_ADC_VAL_shifted));
	/*MY CLOCK IS 28Mhz so i the prescaler will be 27
	 * and i need to proudce and it will make tick every 1us and i need 3KHZ PWM so the ARR= will be 333.33
	 * */
	//	PWM_V=((PWM_V*35)/100);
	MCAL_write_PIN(GPIOA, ACC_DAC_0, ((PWM_V >>0) &1));
	MCAL_write_PIN(GPIOB, ACC_DAC_1, ((PWM_V >>1) &1));
	MCAL_write_PIN(GPIOB, ACC_DAC_2, ((PWM_V >>2) &1));
	MCAL_write_PIN(GPIOB, ACC_DAC_3, ((PWM_V >>3) &1));
	MCAL_write_PIN(GPIOB, ACC_DAC_4, ((PWM_V >>4) &1));
	MCAL_write_PIN(GPIOB, ACC_DAC_5, ((PWM_V >>5) &1));
	MCAL_write_PIN(GPIOB, ACC_DAC_6, ((PWM_V >>6) &1));
	MCAL_write_PIN(GPIOB, ACC_DAC_7, ((PWM_V >>7) &1));

}

/**================================================================
 * @Fn- ACC_Handller_TASK
 * @brief - this task shall to get the distance form luna lidar and start
 * to send the action through can bus to atmega
 * @param [in] - void
 * @param [out] - Void
 * @retval -
 * Note-
 */
void ACC_Handller_TASK(){
	while(1){
		if(xQueueReceive(ACC__AMP_Queue,&ACC_AMP,2)==pdTRUE){
			if((ACC_AMP>=100) && (ACC_AMP<=65535) ){
				if(xQueueReceive(ACC__dis_Queue,&ACC_dis,2)==pdTRUE){
					if(ACC_dis <= Distance_SET){
						// here should send CAN fram to atmega to stop the motor
						ACC_ACTION=ACC_CAR_STOP;
						if(xQueueSend(ACC__ACTION_Queue,&ACC_ACTION,2)==pdTRUE){
						}else{

						}
					}else if((ACC_dis > Distance_SET) &&(ACC_dis <MAX_Distance_SET)){
						ACC_ACTION=ACC_CAR_SLOW_DOWN;
						if(xQueueSend(ACC__ACTION_Queue,&ACC_ACTION,2)==pdTRUE){
						}else{

						}

					}else{
						ACC_ACTION=ACC_CAR_GO;
						if(xQueueSend(ACC__ACTION_Queue,&ACC_ACTION,2)==pdTRUE){
						}else{

						}
					}
				}

			}
			// if the Signal strength indicator not strong dequeue its disance value
			else{
				xQueueReceive(ACC__dis_Queue,&ACC_dis,0);
			}
		}else{

		}
	}

}
/**================================================================
 * @Fn- ACC_LUNA_READ_TASK
 * @brief - this task shall to get distance from LIDAR using UART2
 * @param [in] - void
 * @param [out] - Void
 * @retval -
 * Note-
 */
void ACC_LUNA_READ_TASK(){
	while(1){
		if(xQueueSend(ACC__dis_Queue,&LUNA_dis,2)==pdTRUE){
		}else{

		}
		if(xQueueSend(ACC__AMP_Queue,&LUNA_AMP,2)==pdTRUE){
		}else{

		}
	}
}



/**================================================================
 * @Fn- ACC_throttel_Handller_TASK
 * @brief - this task shall to SEND the volt to the motor drive
 * @param [in] - void
 * @param [out] - Void
 * @retval -
 * Note-
 */

void ACC_throttel_Handller_TASK(){
	uint8_t ACC_action=0,ACC_state=0,ACC_counter=0;
	uint16_t ADC_to_send=0,ADC_SAVED=0;
	while(1){
		xQueueReceive(ACC__ACTION_Queue,&ACC_action,2);
		xQueueReceive(ACC__STATE_Queue,&ACC_state,2);
		if(ACC_state==ACC_ON){
			if(ACC_counter ==0){
				ADC_SAVED=ACC_THROTTEL_DATA;
				ACC_counter++;
			}
			if(ADC_SAVED<ACC_THROTTEL_DATA){
				ACC_FROM_ADC_TO_DAC(ACC_THROTTEL_DATA);

			}else{
				if(ACC_action ==ACC_CAR_STOP){
					ADC_to_send=ACC_FROM_DAC_TO_ADC(0);
					ACC_FROM_ADC_TO_DAC(ADC_to_send);
				}else if(ACC_action ==ACC_CAR_SLOW_DOWN){
					//get the adc val and convert it to pwm and sub 20% from it then change the pwm duty
					ADC_to_send=ACC_FROM_ADC_TO_DAC_DATA(ADC_SAVED);
					if(ADC_to_send>50)
					ADC_to_send=50;
					ADC_to_send=ACC_FROM_DAC_TO_ADC(ADC_to_send);
					ACC_FROM_ADC_TO_DAC(ADC_to_send);
				}else if(ACC_action ==ACC_CAR_GO){
					ACC_FROM_ADC_TO_DAC(ADC_SAVED);

				}
			}


		}else if(ACC_state==ACC_OFF){
			ACC_counter=0;
			if(ACC_action ==ACC_CAR_STOP){
				ADC_to_send=ACC_FROM_DAC_TO_ADC(0);
				ACC_FROM_ADC_TO_DAC(ADC_to_send);
			}else if(ACC_action ==ACC_CAR_SLOW_DOWN){
				//get the adc val and convert it to pwm and sub 20% from it then change the pwm duty
				ADC_to_send=ACC_FROM_ADC_TO_DAC_DATA(ACC_THROTTEL_DATA);
				if(ADC_to_send>50)
				ADC_to_send=50;
				ADC_to_send=ACC_FROM_DAC_TO_ADC(ADC_to_send);
				ACC_FROM_ADC_TO_DAC(ADC_to_send);
			}else if(ACC_action ==ACC_CAR_GO){
				ACC_FROM_ADC_TO_DAC(ACC_THROTTEL_DATA);
			}
		}

	}
}
/**================================================================
 * @Fn- ACC_throttel_Handller_TASK
 * @brief - this task shall to get if the ACC is on or not
 * @param [in] - void
 * @param [out] - Void
 * @retval -
 * Note-
 */

void ACC_STATE_READ_TASK(){
	while(1){

		ACC_ST=MCAL_Read_PIN(ACC_BOTTON_PORT, ACC_BOTTON_PIN);
		ADC_read(ADC1,ACC_THROTTEL_CHx,&ACC_THROTTEL_DATA);
		if(xQueueSend(ACC__STATE_Queue,&ACC_ST,2)==pdTRUE){
		}else{
		}
	}
}
/***********************************/
/***********************************/
/***********************************/
/***********************************/
/***********************************/
/***********************************/












/************TSR TASK*************/
/************TSR TASK*************/
/************TSR TASK*************/
/************TSR TASK*************/






/**================================================================
 * @Fn- TSR_Handller_TASK
 * @brief - this task shall to get the flags from the TSR and decide what sign should printed
 * @param [in] - void
 * @param [out] - Void
 * @retval -
 * Note-
 */
void TSR_Handller_TASK(){
	while(1){
		if(xQueueReceive(TSR__Flags_Queue,&GR_TSR_FLAG_OLED_FINAL,5)==pdTRUE){

			TFT_send_image(GR_TSR_FLAG_OLED_FINAL);
		}else{

		}
	}
}
/**================================================================
 * @Fn- TSR_Flag_Read_TASK
 * @brief - this task shall to send the flags using queue to the handler
 * @param [in] - void
 * @param [out] - Void
 * @retval -
 * Note-
 */
void TSR_Flag_Read_TASK(){
	while(1){
		if(xQueueSend(TSR__Flags_Queue,&GR_TSR_FLAG_OLED_send,1)==pdTRUE){

		}else{

		}
	}
}
/**================================================================
 * @Fn- TSR_call_Back
 * @brief - this task shall to get the flags PC using TSR_UART_INSTANT
 * to send the action through can bus to atmega
 * @param [in] - void
 * @param [out] - Void
 * @retval -
 * Note-
 */
void TSR_call_Back(void){
	  if(  USART1->SR &(1<<5)){
	    PC_Uart_Flag=  MCAL_USART_ReciveData(USART1);


	  }

	  /*
	  0x38 0x2A
	  0x0038
	  0x0008

	  0x0000 | 0x0008
	  0x0008
	   */
	  switch(PC_Uart_Flag){
	  case '#':
	    TSR_START_Flag=1;
	    TSR_END_Flag=0;
	    break;
	  case '*':
	    TSR_END_Flag=1;
	    break;
	  case '/':
	    FACE_START_Flag=1;
	    FACE_END_Flag=0;
	    break;
	  case '+':
	    FACE_END_Flag=1;
	    break;
	  }
	  if (FACE_START_Flag){
	    if(PC_Counter ==0)
	      PC_Uart_Flag=0;

	    if(FACE_END_Flag ==0){
	      GR_FACE_FLAG_ = (GR_FACE_FLAG_<<8)| PC_Uart_Flag;
	      PC_Counter++;
	      /*
	       * 0x0000 | 0x2F =0x
	       *
	       * */

	    }else{
	      GR_FACE_FLAG_ &=0x0F0F;
	      GR_FACE_FLAG_send = ((GR_FACE_FLAG_ &0x0F00)>>4) |((GR_FACE_FLAG_&0x000F));
	      GR_FACE_FLAG_=0;

	      ///////////////
	      FACE_START_Flag=0;
	      FACE_END_Flag=0;
	      PC_Counter=0;
	    }
	  }
	  if(TSR_START_Flag){
	    if(PC_Counter ==0)
	      PC_Uart_Flag=0;

	    if(TSR_END_Flag ==0){
	      GR_TSR_FLAG_OLED = (GR_TSR_FLAG_OLED<<8)| PC_Uart_Flag;
	      PC_Counter++;


	    }else{
	      GR_TSR_FLAG_OLED &=0x0F0F;
	      GR_TSR_FLAG_OLED_send = ((GR_TSR_FLAG_OLED &0x0F00)>>4) |((GR_TSR_FLAG_OLED&0x000F));
	      GR_TSR_FLAG_OLED=0;
	      ///////////////
	      TSR_END_Flag=0;
	      TSR_START_Flag=0;
	      PC_Counter=0;


	    }
	  }










	//  if(PC_Uart_Flag != '*'){
	//    GR_TSR_FLAG_OLED = (GR_TSR_FLAG_OLED<<8)| PC_Uart_Flag;
	//  }else{
	//    GR_TSR_FLAG_OLED &=0x0F0F;
	//    GR_TSR_FLAG_OLED_send = ((GR_TSR_FLAG_OLED &0x0F00)>>4) |((GR_TSR_FLAG_OLED&0x000F));
	//    GR_TSR_FLAG_OLED=0;
	//
	//  }


}


/**================================================================
 * @Fn- TSR_init
 * @brief - this fun shall to init TSR
 * @param [in] - void
 * @param [out] - Void
 * @retval -
 * Note-
 */
void TSR_init(void){
	USART_Config_t UART1_CON={115200,EGHIT_BITS,Parity_DISABLE,Interrupt,ONE_STOP_BIT,Disabled,Asynchronous,TSR_call_Back};
	MCAL_USART_init(TSR_UART_INSTANT, &UART1_CON);
}

/***********************************/
/***********************************/
/***********************************/
/***********************************/
/***********************************/
/***********************************/









/************FACE ID TASK*************/
/************FACE ID TASK*************/
/************FACE ID TASK*************/

void CAR_ON_Handler(){
 if(CAR_ON_counter ==1 &&GR_FACE_FLAG_ !=0x99&&GR_FACE_FLAG_ !=0x00){
		CAR_ON_counter=0;
		//UART SEND
		MCAL_USART_SendData(TSR_UART_INSTANT,CAR_OFF_FLAG);

		vTaskResume(FACE_ID_TASK_Handle);
	}

}
void CAR_ON_init(){
	EXTI_config_t CAR_BOTTON_SITTING={EXT13PC13,FALLING,ENABLE,CAR_ON_Handler};
	MCAL_EXTI_init(&CAR_BOTTON_SITTING);
}
void FACE_ID_TASK(){
	while(1){
		if((MCAL_Read_PIN(GPIOC, PIN_13)==1) ){

			//UART SEND
			if(CAR_login_counter <3){
				if(CAR_login_counter==0){
					MCAL_USART_SendData(TSR_UART_INSTANT,CAR_ON_FLAG);
					CAR_login_counter++;
				}
				if(GR_FACE_FLAG_ ==0x99){
				MCAL_USART_SendData(TSR_UART_INSTANT,CAR_ON_FLAG);
				GR_FACE_FLAG_=0;
				CAR_login_counter++;
				}
			}

			if(GR_FACE_FLAG_ !=0x99 && GR_FACE_FLAG_ !=0x00){
				CAR_ON_counter=1;
				CAR_login_counter=0;
				vTaskSuspend(FACE_ID_TASK_Handle);

			}
		}else{
			CAR_login_counter=0;
		}
	}
}


/***********************************/
/***********************************/
/***********************************/
/***********************************/
/***********************************/
/***********************************/










void HW_init(){
	Sys_Clk_init();
	////////////*********TFT_init***************//////////////////
	TFT_init(RGB_5_6_5);
	////////////*********TSR init***************//////////////////
	TSR_init();
	////////////*********LUNA_INIT***************//////////////////
	LUNA_INIT(CONTIOUS_RANGING_MODE,BYTE_9_CM);
	////////////*********ACC_throtel_init*********//////////////////
	ACC_throtel_init();
	////////////*********DAC init***************//////////////////
	ACC_DAC_init();
	////////////*********DMS_init***************//////////////////
	DMS_init();




}
int main(void)
{
	HW_init();
	///////////////////////////
	if(xTaskCreate(ACC_throttel_Handller_TASK,"ACC_throttel_Handller_TASK",256,NULL,2,NULL)!=pdPASS ){
		Error_Handller();
	}

	if(xTaskCreate(ACC_Handller_TASK,"ACC_Handller_TASK",256,NULL,2,NULL)!=pdPASS ){
		Error_Handller();
	}

	if(xTaskCreate(ACC_LUNA_READ_TASK,"LUNA_READ",256,NULL,2,NULL)!=pdPASS ){
		Error_Handller();
	}
	if(xTaskCreate(ACC_STATE_READ_TASK,"BOTTON_READ",256,NULL,2,NULL)!=pdPASS ){
		Error_Handller();
	}
	///////////////////////

	if(xTaskCreate(TSR_Flag_Read_TASK,"Read_From_UART1",256,NULL,2,NULL)!=pdPASS ){
		Error_Handller();
	}
	if(xTaskCreate(TSR_Handller_TASK,"TSR_Handller_TASK",256,NULL,2,NULL)!=pdPASS ){
		Error_Handller();
	}
	///////////////////////

	if(xTaskCreate(DMS_Handller_TASK,"DMS_Handller_TASK",256,NULL,2,NULL)!=pdPASS ){
		Error_Handller();
	}

	if(xTaskCreate(DMS_read_TASK,"DMS_read_TASK",256,NULL,2,NULL)!=pdPASS ){
		Error_Handller();
	}
	///////////////////////
	if(xTaskCreate(FACE_ID_TASK,"FACE_ID_TASK",256,NULL,5,&FACE_ID_TASK_Handle)!=pdPASS ){
		Error_Handller();
	}



	DMS_Semaphore = xSemaphoreCreateBinary();
	TSR__Flags_Queue=xQueueCreate(10,sizeof(char));
	ACC__dis_Queue=xQueueCreate(10,sizeof(short));
	ACC__AMP_Queue=xQueueCreate(10,sizeof(short));
	ACC__ACTION_Queue=xQueueCreate(10,sizeof(char));
	ACC__STATE_Queue=xQueueCreate(10,sizeof(char));

	vTaskStartScheduler();

	for(;;);
}
