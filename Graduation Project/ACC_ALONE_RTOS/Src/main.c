/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include "main.h"
#include "GP_Timers.h"

uint16_t ACC_THROTTEL_DATA=0x00;
/**================================================================
 * @Fn- Error_Handller
 * @brief - this fun shall to go in infinte loop if there is any thing wrong
 * @param [in] - void
 * @param [out] - Void
 * @retval -
 * Note-
 */

void Sys_Clk_init(){
	// system speed 28Mhz
	RCC->CFGR |=(0b0101 <<18); //1111: PLL input clock x 16
	//	RCC->CFGR |=(0b100<<8); //100: HCLK divided by 2
	//	RCC->CFGR |=(1 <<16); //PLL entry clock source
	//	RCC->CR|=(1<<16); //HSE clock enable

	RCC->CR|=(1<<24); //PLL ON
	RCC->CFGR |=(0b10 <<0); //10: PLL selected as system clock

}

void ACC_ADC_CallBack(){
	ADC_read(ADC1,ACC_THROTTEL_CHx,&ACC_THROTTEL_DATA);

}

void ACC_throtel_init(){
	ADC_Analog_WDG AWDG={0,0,0,0};
	ADC_CONFIG config={ACC_THROTTEL_CHx,ADC_Continuous_conversion,ADC_1_5_cycles,ADC_Polling,&AWDG,ACC_ADC_CallBack};
	ADC_init(ADC1,&config);
//	ADC_interrupt_Enable(ADC1);
	PIN_config PINx={ACC_BOTTON_PIN,INPUT_PD,0};
	MCAL_GPIO_init(ACC_BOTTON_PORT, &PINx);

}
void Error_Handller(){
	while(1);
}

/**================================================================
 * @Fn- TSR_START
 * @brief - this fun shall to start the frame of TSR
 * @param [in] - void
 * @param [out] - Void
 * @retval -
 * Note-
 */


uint16_t ACC_FROM_PWM_TO_ADC(uint8_t PWM_VAL){
	uint16_t ADC=(uint16_t)(((PWM_VAL*ACC_TROTTEL_Max_ADC_VAL_shifted)/(100))+ACC_TROTTEL_MIN_ADC_VAL);

	return ADC;
}
uint16_t ACC_FROM_ADC_TO_PWM_DATA(uint16_t ADC_VAL){
	uint16_t PWM=(uint16_t)(((ADC_VAL-ACC_TROTTEL_MIN_ADC_VAL)*100)/(ACC_TROTTEL_Max_ADC_VAL_shifted));
	return PWM;
}
void ACC_FROM_ADC_TO_PWM(uint16_t ADC_VAL){
	uint16_t PWM_V=(uint16_t)(((ADC_VAL-ACC_TROTTEL_MIN_ADC_VAL)*100)/(ACC_TROTTEL_Max_ADC_VAL_shifted));
	/*MY CLOCK IS 28Mhz so i the prescaler will be 27
	 * and i need to proudce and it will make tick every 1us and i need 3KHZ PWM so the ARR= will be 333.33
	 * */
	PWM_V=((PWM_V*334)/100);
	GP_TIMx__CTC_change(TIM2,2,PWM_V);
}

/**================================================================
 * @Fn- ACC_Handller_TASK
 * @brief - this task shall to get the distance form luna lidar and start
 * to send the action through can bus to atmega
 * @param [in] - void
 * @param [out] - Void
 * @retval -
 * Note-
 */
void ACC_Handller_TASK(){
	while(1){
		if(xQueueReceive(ACC__AMP_Queue,&ACC_AMP,2)==pdTRUE){
			if((ACC_AMP>=100) && (ACC_AMP<=65535) ){
				if(xQueueReceive(ACC__dis_Queue,&ACC_dis,2)==pdTRUE){
					if(ACC_dis <= Distance_SET){
						// here should send CAN fram to atmega to stop the motor
						ACC_ACTION=ACC_CAR_STOP;
						if(xQueueSend(ACC__ACTION_Queue,&ACC_ACTION,2)==pdTRUE){
						}else{

						}
					}else if((ACC_dis > Distance_SET) &&(ACC_dis <MAX_Distance_SET)){
						ACC_ACTION=ACC_CAR_SLOW_DOWN;
						if(xQueueSend(ACC__ACTION_Queue,&ACC_ACTION,2)==pdTRUE){
						}else{

						}

					}else{
						ACC_ACTION=ACC_CAR_GO;
						if(xQueueSend(ACC__ACTION_Queue,&ACC_ACTION,2)==pdTRUE){
						}else{

						}
					}
				}

			}
			// if the Signal strength indicator not strong dequeue its disance value
			else{
				xQueueReceive(ACC__dis_Queue,&ACC_dis,0);
			}
		}else{

		}
	}

}
/**================================================================
 * @Fn- ACC_LUNA_READ_TASK
 * @brief - this task shall to get distance from LIDAR using UART2
 * @param [in] - void
 * @param [out] - Void
 * @retval -
 * Note-
 */
void ACC_LUNA_READ_TASK(){
	while(1){
		if(xQueueSend(ACC__dis_Queue,&LUNA_dis,2)==pdTRUE){
		}else{

		}
		if(xQueueSend(ACC__AMP_Queue,&LUNA_AMP,2)==pdTRUE){
		}else{

		}
	}
}



void HW_init(){
	Sys_Clk_init();

	LUNA_INIT(CONTIOUS_RANGING_MODE,BYTE_9_CM);
	////////////*********ACC_throtel_init*********//////////////////
	ACC_throtel_init();
	////////////*********LUNA_INIT***************//////////////////
	GP_TIMERx_config  PWM_config={27,334,1,344,INT_DIS,PWM,NULL};
	GP_TIMERx_CTC_config CTC_Sitting={ACC_PWM_CHx,PWM_AH,ACTIVE_H};
	GP_TIMx__CTC_start(ACC_PWM_TIMx_INSTANTE,&PWM_config,&CTC_Sitting);





}

void ACC_throttel_Handller_TASK(){
	uint8_t ACC_action=0,ACC_state=0,ACC_counter=0;
	uint16_t ADC_to_send=0,ADC_SAVED=0;
	while(1){
		xQueueReceive(ACC__ACTION_Queue,&ACC_action,2);
		xQueueReceive(ACC__STATE_Queue,&ACC_state,2);
		if(ACC_state==ACC_ON){
			if(ACC_counter ==0){
				ADC_SAVED=ACC_THROTTEL_DATA;
				ACC_counter++;
			}
			if(ADC_SAVED<ACC_THROTTEL_DATA){
				ACC_FROM_ADC_TO_PWM(ACC_THROTTEL_DATA);

			}else{
				if(ACC_action ==ACC_CAR_STOP){
					ADC_to_send=ACC_FROM_PWM_TO_ADC(0);
					ACC_FROM_ADC_TO_PWM(ADC_to_send);
				}else if(ACC_action ==ACC_CAR_SLOW_DOWN){
					//get the adc val and convert it to pwm and sub 20% from it then change the pwm duty
					ADC_to_send=ACC_FROM_ADC_TO_PWM_DATA(ADC_SAVED);
					if(ADC_to_send>50)
					ADC_to_send=50;
					ADC_to_send=ACC_FROM_PWM_TO_ADC(ADC_to_send);
					ACC_FROM_ADC_TO_PWM(ADC_to_send);
				}else if(ACC_action ==ACC_CAR_GO){
					ACC_FROM_ADC_TO_PWM(ADC_SAVED);

				}
			}


		}else if(ACC_state==ACC_OFF){
			ACC_counter=0;
			if(ACC_action ==ACC_CAR_STOP){
				ADC_to_send=ACC_FROM_PWM_TO_ADC(0);
				ACC_FROM_ADC_TO_PWM(ADC_to_send);
			}else if(ACC_action ==ACC_CAR_SLOW_DOWN){
				//get the adc val and convert it to pwm and sub 20% from it then change the pwm duty
				ADC_to_send=ACC_FROM_ADC_TO_PWM_DATA(ACC_THROTTEL_DATA);
				if(ADC_to_send>50)
				ADC_to_send=50;
				ADC_to_send=ACC_FROM_PWM_TO_ADC(ADC_to_send);
				ACC_FROM_ADC_TO_PWM(ADC_to_send);
			}else if(ACC_action ==ACC_CAR_GO){
				ACC_FROM_ADC_TO_PWM(ACC_THROTTEL_DATA);
			}
		}

	}
}
void ACC_STATE_READ_TASK(){
	while(1){

		ACC_ST=MCAL_Read_PIN(ACC_BOTTON_PORT, ACC_BOTTON_PIN);
		ADC_read(ADC1,ACC_THROTTEL_CHx,&ACC_THROTTEL_DATA);
		if(xQueueSend(ACC__STATE_Queue,&ACC_ST,2)==pdTRUE){
		}else{
		}
	}
}
int main(void)
{
	HW_init();

	if(xTaskCreate(ACC_throttel_Handller_TASK,"ACC_throttel_Handller_TASK",256,NULL,2,NULL)!=pdPASS ){
		Error_Handller();
	}

	if(xTaskCreate(ACC_Handller_TASK,"ACC_Handller_TASK",256,NULL,2,NULL)!=pdPASS ){
		Error_Handller();
	}

	if(xTaskCreate(ACC_LUNA_READ_TASK,"LUNA_READ",256,NULL,2,NULL)!=pdPASS ){
		Error_Handller();
	}
	if(xTaskCreate(ACC_STATE_READ_TASK,"BOTTON_READ",256,NULL,2,NULL)!=pdPASS ){
		Error_Handller();
	}

	ACC_Semaphore = xSemaphoreCreateBinary();
	TSR__Flags_Queue=xQueueCreate(10,sizeof(char));
	ACC__dis_Queue=xQueueCreate(10,sizeof(short));
	ACC__AMP_Queue=xQueueCreate(10,sizeof(short));
	ACC__ACTION_Queue=xQueueCreate(10,sizeof(char));
	ACC__STATE_Queue=xQueueCreate(10,sizeof(char));

	vTaskStartScheduler();

	for(;;);
}
